to: velvinh@hotmail.com, mario.vrdoljak@sbcglobal.net

re: "Optimized Head Movement" and "Recording Method"


Hi Vel & Mario,

Thanks for the documents on "Optimized Head Movement" and "Recording Method."  I have some recommendations on both concepts.

I think that it would be difficult and dangerous to attempt to use any sort of physical or pseudo-physical addressing of sectors on the drive.  The LBA concept was adopted because it relieved the system of much overhead, and allowed the drive to handle all the complexities. 

The idea of minimal seeking can be handled using much simpler concepts.  My best idea so far is to use a 'striping' method, where data is initially written in alternating blocks, leaving the blank blocks in between for future writing while the initial blocks are being read.  For example, a file would be written using blocks 0, 2, 4, 8, ...  This would leave blocks 1, 3, 5, 7, ... for writing when the even # blocks are being read.

Setting block size is a trade-off between efficiencies -- mapping size and thruput speed, vs fragmentation.  If we assume that almost all of the files will be very large, I think that we should use a large block size.  For addressing the drive, I propose that we use blocks of N*256 sectors, where N is some power of 2.  256 sectors is the maximum number of sectors that can be read or written at a time using PIO commands.  This would make each block N*256*512 bytes == N*130,000 bytes.  Assuming a 200 Gig drive, this would give us about 1,500,000/N blocks. To map the blocks with 1 bit per block, we would need 1,500,000/4096/N sectors == 400/N sectors.  If N is 16, this would give us a block size of 2 Mbytes, and about 100,000 total blocks.  We would need about 25 sectors for each map.  There should be 2 or 3 copies of the map kept, for redundancy, and all writes of the maps should be done as write/verify.

I understand that the RAM chip used for buffers and program space has 16 Mbytes.  We need to double buffer the data streams to and from the disk, giving us 4 buffers.  With a block and buffer size of 2 Mbytes, we will use 8 Mbytes for data buffers and have 8 Mbytes left for program space and other buffers (such as the block use map and the file structure).

The file structure should be simple, with a list of pointers to headers of files.  Each header for each file will have the file's name, a description, and the list of blocks it uses.  The list could be done in 8-byte sections.  The first 4 bytes would contain a block address, the next 4 bytes would contain the number of blocks in that section.  This would make for easy traversal forward and backward through the data.  The math would also be in 32 bits, which is easy to implement in the programming languages.  There should be 2 or 3 copies of the file structure kept, for redundancy, and all writes should be done as write/verify.

200 Gig is also about the most that can be addressed with a 32-bit (4 byte) LBA.  In use in the IDE standard, 137 Gig is the maximum addressable with 4 bytes.  The standard has been extended to 6 bytes for larger drives, which gives an address space of 7,900 Terabytes.

This is a great project, and I am looking forward to getting to work on the programming.


Sincerely,
Mark



